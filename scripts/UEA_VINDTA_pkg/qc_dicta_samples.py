#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jun 11 15:33:30 2021

@author: Elise Droste (e.droste@uea.ac.uk)



Conventions for this script to work: 
    
    For CRMs and junks:
    - Station = 9999 for junk seawater runs, 8888 for CRM runs
    - Cast = yyyymmdd of analysis for junk seawater runs, CRM batch number for CRM runs 
    - Niskin = junk number of the day for junks, CRM bottle numbre for CRMs 
    - Depth = 0 for junks and CRMs
    - Repeat (same bottle) = automatic repeat run (set by software)
    - Replicate (different bottle) = 1 for junk and CRM runs, unique bottle number for samples
    
    For samples: 
    - Station = station
    - Cast = cast
    - Niksin = niskin
    - Depth = depth
    - Repeat = repeat from the same bottle (automatic)
    - Replicate = replicate/duplicate sample
    
Set column names in the column_names.py style script, as well as identifiers for CRM and junk runs. 
Column_names.py also contains some styling options. 


"""

print("Hello! I hope you've already calculated DIC and/or TA and that you've kept according to the conventions for these scripts.")
print("If you're unsure, check the description of this script. ")

#######################################################################################################################
# Import required built-in packages
import numpy as np
import pandas as pd
#from pathlib import Path
#import os.path
import plotly.graph_objs as go
from plotly.subplots import make_subplots

# Import list of columns names 
from . import column_names



#######################################################################################################################

class QCSamples():
    """
    Class to plot sample variables after CRM QC has been completed. 
    
    Change column names in column_names.py if required. 
    
    """
    
    def __init__(self, df): 
        
        """
        
        args: df = data frame as output for CalcDIC.df instance OR output of CalcDIC.df imported csv file, which is the saved instance of CalcDIC.df generated by MOSAiC_calc_DIC.py
        
        """
        
        self.df = df
        self.crm = self.df[self.df[column_names.station]==8888]
        
        # Convert Date and Time format, create datetime column 
        self.df[column_names.analysisdate] = pd.to_datetime(self.df[column_names.analysisdate])
        self.df[column_names.analysis_datetime] = pd.to_datetime(self.df[column_names.analysis_datetime])
        
        
        # Check if these columns exist and insert if not
        check_columns = [column_names.sampling_date]
        for c in check_columns: 
            if c in self.df.columns:
                print(c + " found in the columns of the DataFrame. Make sure it's correctly populated, i.e. not empty.")
            else: 
                print(c + " is not found in the columns of the DataFrame. Creating it here, but will remain empty.")
                print("Needs to be populated before proceeding with further calculations within this class!" )
                self.df[c] = pd.Series([])
        
    
    
    #######################################################################################################################
    def qc_conc_profiles(self, to_plot=column_names.dic_sample_umol_per_kg): 
        """
        Plot the  concentrations for all samples. Default is dic_sample_umol_per_kg
        Plotted in an interactive plot using plotly so it's easy for the user to identify samples. 
        1 plot (interactive!) per station/cast, colour markers according to cell id, pressure on y axis, concentration on x axis
        
        :args: use_dic = concentration/variable of sample (dic_sample_umol_per_kg is default) 
        
        :returns: creates an instance for plotly figure
        
        Only if interactive mode == "on"
        """
        
        if column_names.interactive == "on":
            
            # Set num, r, and c to zero (used below)
            num = 0
            r = 0 
            c = 0
            
            # Set number of columns for subplots 
            numberofcols = column_names.numberofcols #6#5
            
            # find number of stations (will exclude CRMs)
            # < 20240207 - ED - SDA - added a condition that selects stations based on criteria (e.g. is it a CTD station or UW station) - 
            # If the profile_stations_list is empty, assume all stations are CTD stations and plot them
            if len(column_names.profile_stations_list) == 0: 
                numstations = self.df[column_names.station].loc[self.df[column_names.station] != column_names.crmid].unique() 
            # If the profile_stations_list is not empty, only plot the profiles for the CTD stations included in the list
            else: 
                numstations = self.df[column_names.station].loc[(self.df[column_names.station] != column_names.crmid) & (self.df[column_names.station].isin(column_names.profile_stations_list))].unique() 
            # 20240207 - ED - SDA >
            
            # find the minimum and maximum depths in the dataset. These will be used later for the y axis limits
            min_depth = np.nanmin(self.df[column_names.depth])
            max_depth = np.nanmax(self.df[column_names.depth])
            
            # Create a list for the subplot titles and a dictionary for the station_cast
            subplot_titles = []
            station_casts_dict = {}
            # Set counter for the total number of stations. Will be used to determine number of rows of subplots
            total_stationcasts = 0
            
            # Loop through the stations
            for i in numstations: 
                # Add cast numbers that belong to the station
                station_casts_dict[i] = self.df[column_names.cast].loc[self.df[column_names.station] == i].unique()
                # Loop through the casts per station
                for j in station_casts_dict[i]: 
                    # Create a string for the subplot title that contains info on station and cast 
                    s = "Station " + str(int(i)) + " Cast " + str(int(j))
                    # Add it to the subplot titles list 
                    subplot_titles.append(s)
                    # add 1 to the counter for total number of station/cast combinations
                    total_stationcasts = total_stationcasts + 1

            # Start the figure (number of rows are dependent on total_stationcasts and numberofcols)
            fig = make_subplots(rows=int(total_stationcasts/numberofcols)+1, cols=numberofcols, 
                                subplot_titles = subplot_titles, x_title = to_plot, y_title = "Depth [m]")
            
            # Create a column for colour scheme according to coloured_var ( default is diccellnum)
            numcells = self.df[column_names.coloured_var].unique()
            cell_colours = column_names.cell_colours_list 
            n = 0
            # Set black as the default
            self.df[column_names.cell_colours] = "black" 
            # Start a dictionary which will be the legend for the colours
            thelegend = {}
            for i in numcells:
                self.df[column_names.cell_colours][self.df[column_names.coloured_var] == i] = cell_colours[n]
                thelegend[cell_colours[n]] = i
                n = n + 1
            
            
            # Temporarily fill nans FOR SAMPLES ONLY variable to_plot with zeros (plotly doesn't like the "nan"s)
            # Will be changed back at the end of this module
            self.df[to_plot][self.df[column_names.station] != column_names.crmid] = self.df[to_plot].fillna(0)
            
            # Now loop through each station
            for station in numstations: 
                
                # And per station loop through each cast
                for cast in station_casts_dict[station]:
                    
                    # Assign a row number
                    r = int(num/numberofcols)
                    # Assign a column number
                    c = num % numberofcols 
                    # Assign number 
                    num = num + 1
                    
                    # Plot the data of the station/cast in the subplot
                    fig.add_trace(
                        go.Scatter(
                            x = self.df[to_plot][(self.df[column_names.station] == station) & (self.df[column_names.cast] == cast)].values, 
                            y = self.df[column_names.depth][(self.df[column_names.station] == station) & (self.df[column_names.cast] == cast)].values, 
                            mode = "markers+text", 
                            text = self.df[column_names.coloured_var][(self.df[column_names.station] == station) & (self.df[column_names.cast] == cast)].tolist(), 
                            textposition = "bottom right", 
                            textfont = dict(size = 4), 
                            marker = dict(color = self.df[column_names.cell_colours][(self.df[column_names.station] == station) & (self.df[column_names.cast] == cast)].values), 
                            hovertext = self.df[column_names.sample][(self.df[column_names.station]==station) & (self.df[column_names.cast] == cast)].values,
                        ),
                        row = r+1, 
                        col = c+1)
                    # adjust the y axis range
                    fig.update_yaxes(range = [max_depth, min_depth])
                
            # Update the layout of the entire figure 
            fig.layout.update(height=column_names.fig_height, width=column_names.fig_width, showlegend = False, title_text = "Quality Check Samples", hovermode = "closest")
            fig.show()
            
            # Change any 0 back to nans in "dic_sample_umol_per_kg" or "dic_sample_umol_per_kg_driftcorr" column 
            self.df[to_plot][self.df[column_names.station] != column_names.crmid].replace(to_replace = 0, value = np.nan, inplace = True)
            
            # Return the figure
            self.qc_conc_profiles_fig = fig
            print("Figure saved as self.qc_conc_profiles_fig")
        else: 
            print("Interactive plotting is not switched on. Switch on to see plots generated with Plotly. Otherwise, manually create plots. ")

    #######################################################################################################################
    
    def qc_conc_timeseries(self, to_plot = column_names.dic_sample_umol_per_kg):
        """
        
        Plot the  concentrations for all samples. Default is dic_sample_umol_per_kg
        Plotted in an interactive plot using plotly so it's easy for the user to identify samples
        
        
        :returns: creates an instance for plotly figure
        
        Only if interactive mode == "on"
        
        """
        
        if column_names.interactive == "on":

            # < 20240207 - ED - SDA - commented - 
            # sdates= self.df[column_names.sampling_date][self.df[column_names.station] != column_names.crmid]
            # single_measurements= self.df[to_plot][self.df[column_names.station] != column_names.crmid]
            # 20240207 - ED - SDA >

            # < 20240207 - ED - SDA - added a condition that selects uw stations based on criteria - 
            # If the uw_stations_list is empty, assume all stations are UW stations and plot them
            if len(column_names.uw_stations_list) == 0: 
                sdates= self.df[column_names.sampling_date][self.df[column_names.station] != column_names.crmid]
                single_measurements= self.df[to_plot][self.df[column_names.station] != column_names.crmid]
                single_text = np.array(self.df[column_names.sample].loc[self.df[column_names.station] != column_names.crmid])
            # If the uw_stations_list is not empty, only plot the uw time points for the UW stations included in the list
            else: 
                sdates= self.df[column_names.sampling_date][(self.df[column_names.station] != column_names.crmid) & (self.df[column_names.station].isin(column_names.uw_stations_list))]
                single_measurements= self.df[to_plot][(self.df[column_names.station] != column_names.crmid) & (self.df[column_names.station].isin(column_names.uw_stations_list))]
                single_text = np.array(self.df[column_names.sample].loc[(self.df[column_names.station] != column_names.crmid) & (self.df[column_names.station].isin(column_names.uw_stations_list))])
            # 20240207 - ED - SDA >
            
            if to_plot + "_allcells" in self.df.columns:
                # single_measurements_allcrm= self.df[to_plot + "_allcells"][self.df[column_names.station] != column_names.crmid] # < 20240207 - ED - SDA - commented >
                
                # < 20240207 - ED - SDA - added a condition that selects uw stations based on criteria - 
                # If the uw_stations_list is empty, assume all stations are UW stations and plot them
                if len(column_names.uw_stations_list) == 0: 
                    single_measurements_allcrm= self.df[to_plot + "_allcells"][self.df[column_names.station] != column_names.crmid]
                    single_text = np.array(self.df[column_names.sample].loc[self.df[column_names.station] != column_names.crmid])
                # If the uw_stations_list is not empty, only plot the uw time points for the UW stations included in the list
                else: 
                    single_measurements_allcrm= self.df[to_plot + "_allcells"][(self.df[column_names.station] != column_names.crmid) & (self.df[column_names.station].isin(column_names.uw_stations_list))]
                    single_text = np.array(self.df[column_names.sample].loc[(self.df[column_names.station] != column_names.crmid) & (self.df[column_names.station].isin(column_names.uw_stations_list))])
                # 20240207 - ED - SDA >
                
                
            
            
            # Set lay out properties
            layout = go.Layout(hovermode="closest", title = "Check Concentrations for Time Series", )
    
            # Create figure
            fig = go.Figure(layout=layout)
            
            ###
            fig.add_trace(go.Scatter(
                x = sdates, 
                y = single_measurements, 
                mode = "markers", 
                name = "single measurements - crm per day", 
                text = single_text
            ))
            
            ###
            if to_plot + "_allcells" in self.df.columns:
                fig.add_trace(go.Scatter(
                    x = sdates, 
                    y = single_measurements_allcrm, 
                    mode = "markers", 
                    name = "single measurements - crm total", 
                    text = single_text
                ))
            
    
            # Set axes titles
            fig.update_xaxes(title_text = "Time")
            fig.update_yaxes(title_text = "[umol kg-1]")
    
            fig.show()
            
            self.qc_conc_timeseries_fig = fig
            print("Figure saved as self.qc_conc_timeseries_fig")
            
        else: 
            print("Interactive plotting is not switched on. Switch on to see plots generated with Plotly. Otherwise, manually create plots. ")