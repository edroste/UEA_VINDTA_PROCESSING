#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on 11.05.2021

@author: Elise Droste (e.droste@uea.ac.uk)


Conventions for this script to work: 
    
    For CRMs and junks:
    - Station = 9999 for junk seawater runs, 8888 for CRM runs
    - Cast = yyyymmdd of analysis for junk seawater runs, CRM batch number for CRM runs 
    - Niskin = junk number of the day for junks, CRM bottle numbre for CRMs 
    - Depth = 0 for junks and CRMs
    - Repeat (same bottle) = automatic repeat run (set by software)
    - Replicate (different bottle) = 1 for junk and CRM runs, unique bottle number for samples
    
    For samples: 
    - Station = station
    - Cast = cast
    - Niksin = niskin
    - Depth = depth
    - Repeat = repeat from the same bottle (automatic)
    - Replicate = replicate/duplicate sample


Set column names in the column_names.py style script, as well as identifiers for CRM and junk runs. 
Column_names.py also contains some styling options. 


"""

print("Hello! Before running the CalcTA Class, make sure the filenames of the runs are correct and DIC has been calculated.")

#######################################################################################################################
# Import required built-in packages
import numpy as np
import pandas as pd
from pathlib import Path
import os.path
import calkulate as calk
import plotly.graph_objs as go
from plotly.subplots import make_subplots


# Import self-written modules
from . import crmbatch

# Import list of columns names 
from . import column_names



#######################################################################################################################


class CalcTA():
    """
    Class to determine total alkalinity from raw VINDTA data. 
    Uses Calkulate package. 
    
    Change column names in column_names.py if required. 
    
    Ref: Humphreys, M. P. and Matthews, R. S. (2021). Calkulate: total alkalinity from titration data in Python. Zenodo. doi:10.5281/zenodo.2634304.
    """
    
    def __init__(self, df):
        """
        
        args: df = data frame as output for CalcDIC.df instance OR imported csv file, which is the saved instance of CalcDIC.df generated by MOSAiC_calc_DIC.py
        
        """
        
        self.df_ta = df
        self.crm_ta = self.df_ta[self.df_ta[column_names.station]==8888]
        
        # Convert Date and Time format, create datetime column 
        self.df_ta[column_names.analysisdate] = pd.to_datetime(self.df_ta[column_names.analysisdate])#, format = "%Y%m%d" )
        self.df_ta[column_names.analysis_datetime] = pd.to_datetime(self.df_ta[column_names.analysis_datetime])#, format = "%Y%m%d" )
        
        
        # Check if these columns exist and insert if not
        check_columns = [column_names.sampling_date]
        for c in check_columns: 
            if c in self.df_ta.columns:
                print(c + " found in the columns of the DataFrame. Make sure it's correctly populated, i.e. not empty.")
            else: 
                print(c + " is not found in the columns of the DataFrame. Creating it here, but will remain empty.")
                print("Needs to be populated before proceeding with further calculations within this class!" )
                self.df_ta[c] = pd.Series([])
                
        
        print("Check that nuts are given!")

        # Create "switch" for option to enable interactive plots where applicable/available
        #self.interactive = "on"

    # < 20240211 - ED - SDA - added/copied from previous function and adapted to give option to use cell or date to define acid batches 
    #######################################################################################################################    
    def assign_acidbatch_(self, acidbatchlist, use = "dates"):
        """
        Assign an acid batch (acid top ups or changes). 
        args: 
            acidbatchlist: list with dates in yyy-mm-dd format with mininum number of dates = 1 OR list with DIC cells (int) with minimum of cells = 1
        returns: fills in the dates or cells in the TA Acid Batch column
            use = "dates" or "cells"
        """

        if use == "dates": 
            
            # If there is only 1 date in the list, assign that date to all runs
            if len(acidbatchlist)==1:
                self.df_ta[column_names.taacidbatch] = pd.to_datetime(acidbatchlist[0], format = "%Y-%m-%d")
            # If there are more dates in the list, assign earlier date to all runs bracketed by that and subsequent date. 
            elif len(acidbatchlist)>1:
                # Convert items in list to pandas datetime
                acidbatchlist = [pd.to_datetime(d, format="%Y-%m-%d") for d in acidbatchlist]
                for i in np.arange(len(acidbatchlist[:-1])):
                    self.df_ta[column_names.taacidbatch][((self.df_ta[column_names.analysisdate] >= acidbatchlist[i]) & (self.df_ta[column_names.analysisdate] < acidbatchlist[i+1]))] = acidbatchlist[i] # could also have used np.where()
                self.df_ta[column_names.taacidbatch][self.df_ta[column_names.analysisdate]==acidbatchlist[-1]] = acidbatchlist[-2] # otherwise last analysis day entries don't get an acid batch value
            # If there are no entries in the list
            else: 
                print("No acid batch dates given in the list. Insert 1 date in list if only 1 acid batch was used. Otherwise, insert dates of acid batch top ups or changes, as well as the final date of analysis.") 

        if use == "cells": 
            # If there is only 1 cell in the list, assign that date to all runs
            if len(acidbatchlist)==1:
                self.df_ta[column_names.taacidbatch] = acidbatchlist[0]
            # If there are more cells in the list, assign earlier cell to all runs bracketed by that and subsequent date. 
            elif len(acidbatchlist)>1:
                for i in np.arange(len(acidbatchlist[:-1])):
                    self.df_ta[column_names.taacidbatch][((self.df_ta[column_names.diccellnum] >= acidbatchlist[i]) & (self.df_ta[column_names.diccellnum] < acidbatchlist[i+1]))] = acidbatchlist[i] # could also have used np.where()
                self.df_ta[column_names.taacidbatch][self.df_ta[column_names.diccellnum]==acidbatchlist[-1]] = acidbatchlist[-2] # otherwise last analysis day entries don't get an acid batch value
            # If there are no entries in the list
            else: 
                print("No acid batch dates given in the list. Insert 1 cell in list if only 1 acid batch was used. Otherwise, insert numbers of the cells of acid batch top ups or changes, as well as the final cell of analysis.") 

    # 20240211 - ED - SDA >

    
    #######################################################################################################################    
    # DEPRECATED
    def assign_acidbatch(self, acidbatchlist):
        """
        Assign an acid batch (acid top ups or changes). 
        args: list with dates in yyy-mm-dd format. Mininum number of dates = 1
        returns: fills in the dates in the TA Acid Batch column
        """
        
        # If there is only 1 date in the list, assign that date to all runs
        if len(acidbatchlist)==1:
            self.df_ta[column_names.taacidbatch] = pd.to_datetime(acidbatchlist[0], format = "%Y-%m-%d")
        # If there are more dates in the list, assign earlier date to all runs bracketed by that and subsequent date. 
        elif len(acidbatchlist)>1:
            # Convert items in list to pandas datetime
            acidbatchlist = [pd.to_datetime(d, format="%Y-%m-%d") for d in acidbatchlist]
            for i in np.arange(len(acidbatchlist[:-1])):
                self.df_ta[column_names.taacidbatch][((self.df_ta[column_names.analysisdate] >= acidbatchlist[i]) & (self.df_ta[column_names.analysisdate] < acidbatchlist[i+1]))] = acidbatchlist[i] # could also have used np.where()
            self.df_ta[column_names.taacidbatch][self.df_ta[column_names.analysisdate]==acidbatchlist[-1]] = acidbatchlist[-2] # otherwise last analysis day entries don't get an acid batch value
        # If there are no entries in the list
        else: 
            print("No acid batch dates given in the list. Insert 1 date in list if only 1 acid batch was used. Otherwise, insert dates of acid batch top ups or changes, as well as the final date of analysis.")

    #######################################################################################################################
    def convert_ta_acid_batch(self): 
        # Converting the TA Acid Batch to a number 
        batch_dict = {}
        batch_number = np.arange(len(self.df_ta[column_names.taacidbatch].unique()))
        for batch_number_i, batch_cell in zip(batch_number, self.df_ta[column_names.taacidbatch].unique()): 
            batch_dict[batch_cell] = batch_number_i + 1 # 1 added to make sure it doesn't start with 0
        
        # Create a new series that has the acid batch cells replaced by the sequential numbers
        self.df_ta[column_names.ta_acid_batch_number] = self.df_ta[column_names.taacidbatch].replace(batch_dict)

    # < 20240724 - ESD - AWI - added 
    #######################################################################################################################
    def create_calk_dict(self, path_to_datfiles, calk_dict = "default"): 
        """
        Create instances that contain all information necessary for the calibration of the HCl titrant and the determination of TA. 
        
        
        Args:   path_to_datfiles = string with absolute path to directory where .dat files are stored
                calk_dict = optional argument. Can be set to str(default), which will lead function to create a dictionary and dataframe, 
                            or can be set to a dictionary manually according to Humphreys&Matthews2021. 
        Returns: adds a dictionary (calk_dict) to the class, which can be edited. Will also add ta_acid_batch_number and dic_for_ta columns. 

        For calk_dict input, see: https://calkulate.readthedocs.io/en/latest/metadata/#dataset-column-names
        
        Ref: Humphreys, M. P. and Matthews, R. S. (2021). Calkulate: total alkalinity from titration data in Python. Zenodo. doi:10.5281/zenodo.2634304.
        """
        # Add columns with data necessary for the TA calculations
        self.convert_ta_acid_batch() # Convert the TA acid batch to a sequential number (ta_acid_batch_number added to dataframe)
        dat_filename = self.df_ta[column_names.sample] + ".dat" # Add column with .dat filenames
        self.df_ta[column_names.dic_for_ta] = np.where(self.df_ta[column_names.station] == 8888, self.df_ta[column_names.dic_certified_umolkg], self.df_ta[column_names.dic_sample_umol_per_kg]) # Add series with DIC values used for ta calculations # < 20240724 - ESD - AWI - changed last dic_for_ta to dic_sample_umol_per_kg >
        
        print("Using " + column_names.dic_for_ta + " to calculate TA. Can be changed in column_names file if necessary.")

        if calk_dict == "default":
            # Create a dictionary containing all data required for TA calculations
            self.calk_dict = {"file_name": dat_filename, # Created here 
                         "salinity": self.df_ta[column_names.salinity], # already exists in dataframe
                         "analyte_volume": self.df_ta[column_names.tapipettevol],  # already exists in dataframe
                         "alkalinity_certified": self.df_ta[column_names.ta_certified_umolkg],  # already exists in dataframe
                         "analysis_batch": self.df_ta[column_names.ta_acid_batch_number], # created here (number or name) 
                         "dic": self.df_ta[column_names.dic_for_ta],# created here
                         "file_path": path_to_datfiles, # must be given
                         "total_silicate": self.df_ta[column_names.silicate],
                         "total_phosphate": self.df_ta[column_names.phosphate]
                         # "temperature_override": , # Not given here! If necessary, create non-default dictionary, or simply add to this dictionary once created
                         }
        elif isinstance(calk_dict, dict):
            calk_dict = calk_dict
            # Create a DataFrame out of the dictionary 
            self.ds_ta_calk = pd.DataFrame(calk_dict)
            # Convert DataFrame into a Dataset (Calkulate)
            self.ds_ta_calk = calk.Dataset(self.ds_ta_calk)
            print("Find DataFrame as self.ds_ta_calk - to be used in TA calculations")
        
        else: 
            print("Either set calk_dict to str(default), a dictionary in line with docs in Humphreys&Matthews2021, or omit calk_dict to allow default.")

    # 20240724 - ESD - AWI >
    
    # < 20240724 - ESD - AWI - copied and rewritten from create_calc_file_
    #######################################################################################################################
    def create_calk_ds(self): 
        """
        Create instances that contain all information necessary for the calibration of the HCl titrant and the determination of TA. 
        
        Args:   None. Will use the calk_dict of the class. 
        
        Returns: The dataframe and dataset are added as instances (df_ta_calk and ds_ta_calk, respectively) to the class. 
                These can be used as input for the calibration of HCl molinity and determination of TA (different functions). 
        """
        # Create a DataFrame out of the dictionary 
        self.ds_ta_calk = pd.DataFrame(self.calk_dict)
    
        # Convert DataFrame into a Dataset (Calkulate)
        self.ds_ta_calk = calk.Dataset(self.ds_ta_calk)
        print("Find DataFrame as self.ds_ta_calk - to be used in TA calculations. Edit if necessary. ")
        
    # 20240724 - ESD - AWI >

    
    #######################################################################################################################
    # DEPRECATED
    def create_calk_file(self, path_to_datfiles, calk_dict="default"): 
        """
        Create instances that contain all information necessary for the calibration of the HCl titrant and the determination of TA. 
        
        
        Args:   path_to_datfiles = string with absolute path to directory where .dat files are stored
                calk_dict = optional argument. Can be set to str(default), which will lead function to create a dictionary and dataframe, 
                            or can be set to a dictionary manually according to Humphreys&Matthews2021. 
        
        Returns: The dataframe and dataset are added as instances (df_ta_calk and ds_ta_calk, respectively) to the class. 
                These can be used as input for the calibration of HCl molinity and determination of TA (different functions). 
        
        For calk_dict inout, see: https://calkulate.readthedocs.io/en/latest/metadata/#dataset-column-names
        
        Ref: Humphreys, M. P. and Matthews, R. S. (2021). Calkulate: total alkalinity from titration data in Python. Zenodo. doi:10.5281/zenodo.2634304.
        """
        if calk_dict == "default":

            # Create the columns that do not yet exist but are needed for the functions to work
            dat_filename = self.df_ta[column_names.sample] + ".dat"
            dat_filepath = path_to_datfiles

            # < 20240724 - ESD - AWI - commented (rewritten below)
            # Converting the TA Acid Batch to a number 
            # batch_no = np.arange(len(self.df_ta[column_names.taacidbatch].unique()))
            # batch_dict = {}
            # i = 0
            # for batch in self.df_ta[column_names.taacidbatch].unique():
            #     # batch = pd.Timestamp(batch) # not necessary
            #     batch_dict[batch] = batch_no[i] + 1
            #     i = i + 1
            # self.df_ta[column_names.ta_acid_batch_number] = pd.Series([])
            # for batch in batch_dict: 
            #     self.df_ta[column_names.ta_acid_batch_number].loc[self.df_ta[column_names.taacidbatch] == batch] = batch_dict[batch]
            # 20240724 - ESD - AWI >

            # < 20240724 - ESD - AWI - added
            # Converting the TA Acid Batch to a number 
            batch_dict = {}
            batch_number = np.arange(len(self.df_ta[column_names.taacidbatch].unique()))
            for batch_number_i, batch_cell in zip(batch_number, self.df_ta[column_names.taacidbatch].unique()): 
                batch_dict[batch_cell] = batch_number_i + 1 # 1 added to make sure it doesn't start with 0
            
            # Create a new series that has the acid batch cells replaced by the sequential numbers
            self.df_ta[column_names.ta_acid_batch_number] = self.df_ta[column_names.taacidbatch].replace(batch_dict)
            # 20240724 - ESD - AWI >

            # < 20240724 - ESD - AWI - commented (rewritten below)
            # ta_acid_batch_number = self.df_ta[column_names.ta_acid_batch_number]
            # self.df_ta.drop(columns = column_names.ta_acid_batch_number) # drop because will be added later anyway
            # 20240724 - ESD - AWI >
            
            # For DIC, I want to use the calculated DIC values for the samples and the certified values for the CRMs. 
            # The DIC values to be used can be changed in the column_names file
            # < 20240724 - ESD - AWI - commented 
            # dic_calk = np.where(self.df_ta[column_names.station] == 8888, self.df_ta[column_names.dic_certified_umolkg], self.df_ta[column_names.dic_for_ta])
            # 20240724 - ESD - AWI >

            # < 20240724 - ESD - AWI - added and changed last dic_for_ta to dic_sample_umol_per_kg
            self.df_ta[column_names.dic_for_ta] = np.where(self.df_ta[column_names.station] == 8888, self.df_ta[column_names.dic_certified_umolkg], self.df_ta[column_names.dic_for_ta])
            # 20240724 - ESD - AWI >
            
            print("Using " + column_names.dic_for_ta + " to calculate TA. Can be changed in column_names file if necessary.")
        
            # Create a dictionary 
            calk_dict = {"file_name": dat_filename, # Created here 
                         "salinity": self.df_ta[column_names.salinity], # already exists in dataframe
                         "analyte_volume": self.df_ta[column_names.tapipettevol],  # already exists in dataframe
                         "alkalinity_certified": self.df_ta[column_names.ta_certified_umolkg],  # already exists in dataframe
                         "analysis_batch": self.df_ta[column_names.ta_acid_batch_number], # created here (number or name) # < 20240724 - ESD - AWI - changed from ta_acid_batch_number >
                         "dic": self.df_ta[column_names.dic_for_ta],# created here # < 20240724 - ESD - AWI - changed from dic_calk > 
                         "file_path": dat_filepath, # must be given
                         # "temperature_override": , # Not given here! If necessary, then create non-default dictionary
                         # < ED - 20221206 - UEA - Uncommented, trying again... 
                         # < ED - 20221206 - UEA - Temporarily commented... 
                         # < ED - 20221205 - UEA - Added nuts 
                         #"total_phosphate": self.df_ta[column_names.phosphate], 
                         #"total_silicate": self.df_ta[column_names.silicate]
                         "total_silicate": self.df_ta[column_names.silicate],
                         "total_phosphate": self.df_ta[column_names.phosphate]
                         # ED - 20221205 - UEA > 
                         # ED - 20221206 - UEA > 
                         # ED - 20221206 - UEA > 
                         }
            #print("Nuts used incl. in dict.! Check that nuts are there. ")
        
            # Create a DataFrame out of the dictionary 
            self.ds_ta_calk = pd.DataFrame(calk_dict)
        
            # Convert DataFrame into a Dataset (Calkulate)
            self.ds_ta_calk = calk.Dataset(self.ds_ta_calk)
            print("Find DataFrame as self.ds_ta_calk")
        
        elif isinstance(calk_dict, dict):
            calk_dict = calk_dict
            # Create a DataFrame out of the dictionary 
            self.ds_ta_calk = pd.DataFrame(calk_dict)
            # Convert DataFrame into a Dataset (Calkulate)
            self.ds_ta_calk = calk.Dataset(self.ds_ta_calk)
            print("Find DataFrame as self.ds_ta_calk")
        
        else: 
            print("Either set calk_dict to str(default), a dictionary in line with docs in Humphreys&Matthews2021, or omit calk_dict to allow default.")

    #######################################################################################################################
    
    def hcl_conc(self):
        """
        Determine the HCl concentration per HCl batch, using Calkulate package VERSION 23. 
        Will in addition calculate the standard deviation of the titrant molinity per batch (titrant_molinity_std_batch). 
        """
        
        # Calibrate the titrant molinity
        self.ds_ta_calk.calibrate() # in place
        
        # Calculate the standard deviation per acid batch
        self.ds_ta_calk[column_names.titrant_molinity_std_batch] = self.ds_ta_calk[column_names.titrant_molinity_here].groupby(self.ds_ta_calk[column_names.analysis_batch]).transform("std")
        
        print("Standard deviation per batch also calculated.")
        print("Find calibrated titrant data added to self.ds_ta_calk DataFrame :) ")
        
    #######################################################################################################################
    def plot_hcl_conc(self):
        """
        Plot the titrant acid molinity. Run this after titrant molinity has been calibrated. 
        """
        
        from . import column_names
        
        if column_names.interactive == "on":
            # Plot it all in an interactive graph 
            if len(self.df_ta[column_names.taacidbatch].unique()) > 1: 
                
                layout = go.Layout(hovermode="closest", title = "Acid Titrant Concentration")
                
                fig = go.Figure(layout=layout)
                
                fig.add_trace(go.Scatter(
                        x = self.df_ta[column_names.analysis_datetime], 
                        y = self.ds_ta_calk[column_names.titrant_molinity_here], 
                        error_y = dict(type = "data", array = self.ds_ta_calk[column_names.titrant_molinity_std_batch], visible = True),
                        mode = "lines+markers", 
                        marker = dict(color = "darkturquoise"),
                        name = column_names.titrant_molinity_here, 
                        text = np.array(self.df_ta[column_names.sample]) 
                        ))
        
                fig.add_trace(go.Scatter(
                            x = self.df_ta[column_names.analysis_datetime], 
                            y = self.ds_ta_calk[column_names.titrant_molinity_here], 
                            mode = "markers", 
                            marker = dict(color = "DarkSlateGrey", line = dict(color = "black")), 
                            name = column_names.titrant_molinity_here, 
                            text = np.array(self.df_ta[column_names.sample]) 
                            ))
    
                fig.update_xaxes(title_text = "Time")
                fig.update_yaxes(title_text = "HCl [M]")
            
            elif len(self.df_ta[column_names.taacidbatch].unique()) == 1: 
                
                titrant_mean = np.nanmean(self.ds_ta_calk[column_names.titrant_molinity_here])
                titrant_std = np.nanstd(self.ds_ta_calk[column_names.titrant_molinity_here])
    
                layout = go.Layout(hovermode="closest", title = "Acid Titrant Concentration")
                
                fig = go.Figure(layout=layout)
                
                fig.add_hline(y=titrant_mean, line_width=3, line_color="RoyalBlue", 
                              annotation_text="mean", annotation_position="bottom right", annotation_font_size=16, annotation_font_color="black")
                fig.add_hline(y=titrant_mean + 2*titrant_std, line_width=3, line_dash="dashdot", line_color="MediumPurple", 
                              annotation_text="+2sigma", annotation_position="bottom right", annotation_font_size=16, annotation_font_color="black")
                fig.add_hline(y=titrant_mean - 2*titrant_std, line_width=3, line_dash="dashdot", line_color="MediumPurple", 
                              annotation_text="-2sigma", annotation_position="bottom right", annotation_font_size=16, annotation_font_color="black")
                fig.add_hline(y=titrant_mean + 3*titrant_std, line_width=3, line_dash="dot", line_color="LightSeaGreen", 
                              annotation_text="+3sigma", annotation_position="bottom right", annotation_font_size=16, annotation_font_color="black")
                fig.add_hline(y=titrant_mean - 3*titrant_std, line_width=3, line_dash="dot", line_color="LightSeaGreen", 
                              annotation_text="-3sigma", annotation_position="bottom right", annotation_font_size=16, annotation_font_color="black")
                
                fig.add_trace(go.Scatter(
                        x = self.df_ta[column_names.analysis_datetime], 
                        y = self.ds_ta_calk[column_names.titrant_molinity_here], 
                        mode = "lines+markers", 
                        marker = dict(color = "darkturquoise"),
                        name = column_names.titrant_molinity_here, 
                        text = np.array(self.df_ta[column_names.sample]) 
                        ))
        
                fig.add_trace(go.Scatter(
                            x = self.df_ta[column_names.analysis_datetime], 
                            y = self.ds_ta_calk[column_names.titrant_molinity_here], 
                            mode = "markers", 
                            marker = dict(color = "DarkSlateGrey", line = dict(color = "black")), 
                            name = column_names.titrant_molinity_here, 
                            text = np.array(self.df_ta[column_names.sample]) 
                            ))
    
                fig.update_xaxes(title_text = "Time")
                fig.update_yaxes(title_text = "HCl [M]")
                
            else: 
                print("No acid batches found. ")

            fig.show()
            
            self.plot_hcl_conc_fig = fig
            print("Figure saved as self.plot_hcl_conc_fig");
            
        else:
            print("Interactive plotting is not switched on. Switch interactive on if you would like to see the graphs generated with Plotly. Otherwise, manually create plots. ")
            
    
    #######################################################################################################################
    
    def hcl_conc_calkv2(self, dat_input_in, crm_dickson_vars):
        """
        Determine the HCl concentration per HCl batch, using Calkulate package VERSION 2
        Note that for this method, the HCl batch number should already be assigned and the crm variables should be defined. 
        See assign_acidbatch(). 
        
        :args: dat_input_in is the path in ".../.../..." format
        
        :returns: plotly figure with mean acid concentration per batch and optimal results for acid concentrations for all CRMs
        
        Method also adds a series to the DataFrame, called "concAcid_mean_batch"
        
        Refs: Humphreys, M. P. and Matthews, R. S. (2021). Calkulate: total alkalinity from titration data in Python. Zenodo. doi:10.5281/zenodo.2634304.

        """
        
        self.df_ta[column_names.titrant_molinity_here] = np.float("NaN")
    
        for crm in self.df_ta[column_names.sample][(self.df_ta[column_names.station] == 8888) & (self.df_ta[column_names.taflag] != 3)]: # i.e. for all crms/find all crms in list << 20200131 - ED - UEA - excl. CRMs with TA flag = 3 >> 
            datFile_crm = crm + ".dat"
            
            
            if os.path.isfile(dat_input_in + "/" + datFile_crm): #check if the file exists
                datFile_crm = Path(dat_input_in) / datFile_crm
                
                # Set the following variables to the certified values of the CRMs
                # These have been inserted per CRM batch in the PS117_DIC.ipynb script
                # Units for DIC, AT, and nutrients are in umol/kg and need to be converted to mol/kg (conversion factor = 10**-6) in order for the calkulate package to work 
                crm_vol = self.df_ta[column_names.tapipettevol].loc[self.df_ta[column_names.sample] == crm].item()
                crm_alk = self.df_ta[column_names.ta_certified_umolkg].loc[self.df_ta[column_names.sample] == crm].item()*10**-6
                crm_dic = self.df_ta[column_names.dic_certified_umolkg].loc[self.df_ta[column_names.sample] == crm].item()*10**-6 
                crm_phos = self.df_ta[column_names.phosphate].loc[self.df_ta[column_names.sample] == crm].item()*10**-6
                crm_sil = self.df_ta[column_names.silicate].loc[self.df_ta[column_names.sample] == crm].item()*10**-6
                crm_sal = self.df_ta[column_names.salinity].loc[self.df_ta[column_names.sample] == crm].item()
                
                
                # Determine the HCl concentrations
                concAcidOptResult = calk.vindta.concAcid(datFile_crm, crm_vol, crm_alk, crm_sal, crm_dic, crm_phos, crm_sil, solver = "complete")['x'][0]
                self.df_ta[column_names.titrant_molinity_here][self.df_ta[self.df_ta[column_names.sample] == crm].index] = concAcidOptResult
    
            else:
                print("File " + datFile_crm + " is not in specified directory -> Variables not calculated. See analysis day "+ 
                      str(self.df_ta[column_names.analysisdate][self.df_ta[column_names.sample]==crm]))
                
        # Take average of concAcid per batch (TA Acid Batch) and create a column that contains the average per batch
        self.df_ta[column_names.titrant_molinity] = self.df_ta[column_names.titrant_molinity_here].groupby(self.df_ta[column_names.taacidbatch]).transform("mean")
        # Also calculate the standard deviation
        self.df_ta[column_names.titrant_molinity_std_batch] = self.df_ta[column_names.titrant_molinity_here].groupby(self.df_ta[column_names.taacidbatch]).transform("std")
        
        # Plot it all in an interactive graph 
        layout = go.Layout(hovermode="closest", # to make sure hover text appears for points that share an x value
                   title = "Acid Concentration", 
        #          xaxis_rangeslider_visible = True
                  )
        
        # Create a new column containing the datetime for the analysis of each run (useful in plotting how parameters change over time)
        #self.df_ta[column_names.datetime_analysis] =  pd.to_datetime(self.df_ta[column_names.analysisdate].astype(str)+ " " +self.df_ta[column_names.analysistime].astype(str), format = "%Y%m%d %H%M%S")
        
        if column_names.interactive == "on":
            fig = go.Figure(layout=layout)
            
            fig.add_trace(go.Scatter(
                    x = self.df_ta[column_names.analysis_datetime], 
                    y = self.df_ta[column_names.titrant_molinity], 
                    error_y = dict(type = "data", array = self.df_ta[column_names.titrant_molinity_std_batch], visible = True),
                    mode = "lines+markers", 
                    marker = dict(color = "darkturquoise"),
                    name = column_names.titrant_molinity, 
                    text = np.array(self.df_ta[column_names.sample]) 
                    ))
    
            fig.add_trace(go.Scatter(
                        x = self.df_ta[column_names.analysis_datetime], 
                        y = self.df_ta[column_names.titrant_molinity], 
                        mode = "markers", 
                        marker = dict(color = "DarkSlateGrey", line = dict(color = "black")), 
                        name = column_names.titrant_molinity, 
                        text = np.array(self.df_ta[column_names.sample]) 
                        ))
    
            
    
            fig.update_xaxes(title_text = "Time")
            fig.update_yaxes(title_text = "[HCl]")
    
            fig.show()
            
            self.hcl_conc_calkv2_fig = fig
            print("Figure saved as self.hcl_conc_calkv2_fig")
            
        else: 
            print("Interactive plotting is not switched on. Switch on to see plots generated with Plotly. Otherwise, manually create plots. ")
        
    #######################################################################################################################
    def calc_ta(self): 
        """
        Determine TA concentration using Calkulate package VERSION 23. 
        
        Dataset will be altered in place. Merge the resulting dataframe with the original dataframe containing the rest if the data.   
        In merged dataset, rename the alkalinity column from alkalinity to alkalinity_umolkg
        
        """
        
        self.ds_ta_calk.solve() # in place
        
        # Merge the dataset with the rest (all info in the same place)
        self.df_ta = pd.concat([self.df_ta, self.ds_ta_calk], axis=1, join = "outer")
        
        # Re-name the alkalinity column 
        self.df_ta.rename(columns = {"alkalinity": column_names.alkalinity_umolkg, 
                                     "titrant_molinity_here": column_names.titrant_molinity_here, 
                                     "titrant_molinity": column_names.titrant_molinity,
                                     "titrant_molinity_std_batch": column_names.titrant_molinity_std_batch}, inplace = True)
        
    #######################################################################################################################    
    def calc_ta_calkv2(self, dat_input_in):
        """
        Determine TA concentration using Calkulate package VERSION 2
        Args: 
            
        Returns: 
        
        Refs: Humphreys, M. P. and Matthews, R. S. (2021). Calkulate: total alkalinity from titration data in Python. Zenodo. doi:10.5281/zenodo.2634304.
        """
        
        # Check if the alkalinity column already exists. Create a new column if not. 
        if column_names.alkalinity_umolkg in self.df_ta.columns:
            pass
        else:
            self.df_ta[column_names.alkalinity_umolkg] = np.float("NaN")
        
        # Calculate the total alkalinity for samples
        for sample in self.df_ta[column_names.sample][self.df_ta[column_names.station] != 8888]:
            datFile = sample + ".dat"
        
            if os.path.isfile(dat_input_in + "/" + datFile):
                datFile = Path(dat_input_in) / datFile
                
                try: 
                    # Set variables. Make sure nutrients are in mol/kg
                    volSample = np.float(self.df_ta[column_names.tapipettevol][self.df_ta[column_names.sample] == sample]) # [mL]
                    concAcid = np.float(self.df_ta[column_names.titrant_molinity][self.df_ta[column_names.sample] == sample]) #[] ENTER UNIT
                    # < ED - 20210311 - Norwich - changed dic_sample_umol_per_kg --> dic_sample_umol_per_kg_final 
                    totalCarbonate = np.float(self.df_ta[column_names.dic_sample_umol_per_kg_final][self.df_ta[column_names.sample] == sample])*10**-6 # mol/kg
                    # ED - 20210311 - Norwich >
                    pSal = np.float(self.df_ta[column_names.salinity][self.df_ta[column_names.sample] == sample]) # 35 for samples. Real values still need to be inserted. 
                    totalPhosphate = np.float(self.df_ta[column_names.phosphate][self.df_ta[column_names.sample] == sample])*10**-6 # mol/kg
                    totalSilicate = np.float(self.df_ta[column_names.silicate][self.df_ta[column_names.sample] == sample])*10**-6 # mol/kg
                    
                    
                    # Calculate alkalinity
                    # x = [alkalinity, emf0]
                    alkalinity = calk.vindta.alk(datFile, volSample, concAcid, pSal, totalCarbonate, totalPhosphate, totalSilicate, 
                                                 solver='complete', buretteCorrection=1, tempKForce=None)["x"][0]*10**6 # conversion to umol/kg
                    self.df_ta[column_names.alkalinity_umolkg][self.df_ta[self.df_ta[column_names.sample] == sample].index] = alkalinity
                    
                except ValueError:
                    print("Check that units for nutrients and DIC are in mol/kg for sample " + sample + " (ValueError)")
                    continue
                
                except TypeError:
                    print("Figure this out: " + sample + " (TypeError)")
                    continue
                
                
            else: 
                print(datFile + " not found. Alkalinity not determined. ")
            
        
        # << 20200131 - ED - UEA - I added the calculation of the TA for CRMs
        # Calculate the total alkalinity for CRMs
        
        # Find all crm batches that have been used in this part of the data set
        unique_crm_batches = self.df_ta[column_names.crm_batch].unique()
        # Create a dictionary with dictionaries for all crm batches that are used in this part of the dataset  (typically just 1 batch type)
        crm_batches_dict = {}
        for i in unique_crm_batches: 
            crm_dickson_vars_add = crmbatch.findcrmbatch(i)
            crm_batches_dict[i] = crm_dickson_vars_add

        # Now loop through each CRM and find its .dat file 
        for crm in self.df_ta[column_names.sample][self.df_ta[column_names.station] == 8888]:
            datFile = crm + ".dat"

            if os.path.isfile(dat_input_in + "/" + datFile): 
                datFile = Path(dat_input_in)/ datFile

                try:
                    crm_batch = np.int(self.df_ta[column_names.crm_batch][self.df_ta[column_names.sample] == crm])
                    crm_dickson_vars = crm_batches_dict[crm_batch] # dictionary

                    # Set variables
                    volSample = np.float(self.df_ta[column_names.tapipettevol][self.df_ta[column_names.sample] == crm]) # calibrated
                    concAcid = np.float(self.df_ta[column_names.titrant_molinity][self.df_ta[column_names.sample] == crm]) # calculated/calibrated
                    totalCarbonate = np.float(self.df_ta[column_names.dic_sample_umol_per_kg_final][self.df_ta[column_names.sample] == crm])*10**-6 # mol/kg # calculated
                    pSal = np.float(self.df_ta[column_names.sample][self.df_ta[column_names.sample] == crm]) # certified
                    totalPhosphate = np.float(crm_dickson_vars["phos"])*10**-6 # mol/kg # certified
                    totalSilicate = np.float(crm_dickson_vars["sil"] )*10**-6 # mol/kg # certified

                    # Determine the TA 
                    alkalinity = calk.vindta.alk(datFile, volSample, concAcid, pSal, totalCarbonate, totalPhosphate, totalSilicate, 
                                                 solver='complete', buretteCorrection=1, tempKForce=None)["x"][0]*10**6 # conversion to umol/kg
                    self.df_ta[column_names.alkalinity_umolkg][self.df_ta[self.df_ta[column_names.sample] == crm].index] = alkalinity

                except ValueError:
                    print("Check that units for nutrients and DIC are in mol/kg for sample " + crm + " (ValueError)")
                    continue


            else: 
                print(datFile + " not found. Alkalinity not determined. ")
                # 20200131 - ED - UEA >>
        
    
    #######################################################################################################################
    def ta_x_chart(self):
        
        # Select only the CRM runs
        df = self.df_ta[self.df_ta[column_names.station] == column_names.crmid].reset_index(drop = True)
        
        ta_mean = np.nanmean(df[column_names.alkalinity_umolkg])
        ta_std = np.nanstd(df[column_names.alkalinity_umolkg])
        
        
        if column_names.interactive == "on":
            #layout = go.Layout(hovermode="closest", title = "Total Alkalinity X Chart")
            
            fig = go.Figure()#layout=layout)
            
            fig.add_hline(y=ta_mean, line_width=3, line_color="DarkSlateGrey", 
                          annotation_text="mean", annotation_position="bottom right", annotation_font_size=16, annotation_font_color="black")
            fig.add_hline(y=ta_mean + 2*ta_std, line_width=3, line_dash="dash", line_color="darkturquoise", 
                          annotation_text="+2sigma", annotation_position="bottom right", annotation_font_size=16, annotation_font_color="black")
            fig.add_hline(y=ta_mean - 2*ta_std, line_width=3, line_dash="dash", line_color="darkturquoise", 
                          annotation_text="-2sigma", annotation_position="bottom right", annotation_font_size=16, annotation_font_color="black")
            fig.add_hline(y=ta_mean + 3*ta_std, line_width=3, line_dash="dot", line_color="darkturquoise", 
                          annotation_text="+3sigma", annotation_position="bottom right", annotation_font_size=16, annotation_font_color="black")
            fig.add_hline(y=ta_mean - 3*ta_std, line_width=3, line_dash="dot", line_color="darkturquoise", 
                          annotation_text="-3sigma", annotation_position="bottom right", annotation_font_size=16, annotation_font_color="black")
    
            fig.add_trace(go.Scatter(
                        x = df.index, 
                        y = df[column_names.alkalinity_umolkg], 
                        mode = "markers", 
                        marker = dict(color = "DarkSlateGrey", line = dict(color = "black")), 
                        name = column_names.alkalinity_umolkg, 
                        text = np.array(df[column_names.sample]) 
                        ))
    
            fig.update_xaxes(title_text = "Sequence")
            fig.update_yaxes(title_text = "TA [umol/kg]")
            
            fig.update_traces(showlegend=False)
            fig.update_layout(hovermode="closest")
            fig.update_layout(font_size=14)
            
            fig.show()
            
            self.ta_x_chart_fig = fig
            print("Figure saved as self.ta_x_chart_fig")
        else: 
            print("Interactive plotting is not switched on. Switch on to see plots generated with Plotly. Otherwise, manually create plots. ")
        
    
    
    
    
    #######################################################################################################################

    def qc_conc_profiles(self, to_plot="alkalinity_umolkg"): 
        """
        Plot the TA concentrations calculated within this class for all samples. 
        Plotted in an interactive plot using plotly so it's easy for the user to identify samples. 
        1 plot (interactive!) per station/cast, colour markers according to cell id, pressure on y axis, concentration on x axis
        
        :args:  =  alkalinity_umolkg
        
        :returns: plotly figure
        """
        
        if column_names.interactive == "on":

            num = 0
            r = 0 
            c = 0
            
            numberofcols = column_names.numberofcols # 6#5
            
            numstations = self.df[column_names.station].loc[self.df[column_names.station] != column_names.crmid].unique() # find number of stations (station value for CRMs is "nan", so we're excluding those)
            min_depth = np.nanmin(self.df[column_names.depth])
            max_depth = np.nanmax(self.df[column_names.depth])
            
            subplot_titles = []
            station_casts_dict = {}
            total_stationcasts= 0
            
            for i in numstations: 
                station_casts_dict[i] = self.df[column_names.cast].loc[self.df[column_names.station] == i].unique()
                for j in station_casts_dict[i]: 
                    s = "Station " + str(int(i)) + " Cast " + str(int(j))
                    subplot_titles.append(s)
                    total_stationcasts = total_stationcasts + 1
            
            fig = make_subplots(rows=int(len(total_stationcasts)/numberofcols)+1, cols=numberofcols, subplot_titles = subplot_titles, x_title = "TA [umol kg-1]", y_title = "Depth [m]")
            
            # Create a column for colour scheme according to DIC cell 
            numcells = self.df[column_names.diccellnum].unique()
            cell_colours = ["firebrick", "darkorange", "blue",
                            "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "darkolivegreen", "cornflowerblue",
                            "crimson", "cyan", "darkblue", "darkcyan","darkgoldenrod", "darkgray", "darkgreen",
                            "darkkhaki", "darkmagenta","darkorchid", "darkred", "darksalmon", "darkseagreen",
                            "darkslateblue", "darkslategray", "darkslategrey","darkturquoise", "darkviolet", "deeppink", "deepskyblue",
                            "dimgrey", "dodgerblue", "forestgreen", "cornsilk"]
            n = 0
            self.df["cell_colour"] = "black"
            thelegend = {}
            for i in numcells:
                self.df["cell_colour"][self.df[column_names.diccellnum] == i] = cell_colours[n]
                thelegend[cell_colours[n]] = i
                n = n + 1
            
            
            # Temporarily fill nans FOR SAMPLES ONLY in "dic_sample_umol_per_kg" (or "dic_sample_umol_per_kg_driftcorr") with zeros (plotly doesn't like the "nan"s)
            self.df[to_plot][self.df[column_names.station] != column_names.crmid] = self.df[to_plot].fillna(0)
            
            for station in numstations: 
                
                for cast in station_casts_dict[station]:
                
                    r = int(num/numberofcols)
                    c = num % numberofcols        
                    num = num + 1
                    
                    
            
                    fig.add_trace(
                        go.Scatter(
                            x = self.df[to_plot][(self.df[column_names.station] == station) & (self.df[column_names.cast] == cast)].values, 
                            y = self.df[column_names.depth][(self.df[column_names.station] == station) & (self.df[column_names.cast] == cast)].values, 
                            mode = "markers+text", 
                            text = self.df[column_names.diccellnum][(self.df[column_names.station] == station) & (self.df[column_names.cast] == cast)].tolist(), 
                            textposition = "bottom right", 
                            textfont = dict(size = 4), 
                            marker = dict(color = self.df["cell_colour"][(self.df[column_names.station] == station) & (self.df[column_names.cast] == cast)].values), 
                            hovertext = self.df[column_names.sample][(self.df[column_names.station]==station) & (self.df[column_names.cast] == cast)].values,
                        ),
                        row = r+1, 
                        col = c+1)
        
                    fig.update_yaxes(range = [max_depth, min_depth])
                
            
            fig.layout.update(height=3500, width=1000, showlegend = False, title_text = "Quality Check Samples", hovermode = "closest")
            fig.show()
            
            # Change any 0 back to nans in "dic_sample_umol_per_kg" or "dic_sample_umol_per_kg_driftcorr" column 
            self.df[to_plot][self.df[column_names.station] != column_names.crmid].replace(to_replace = 0, value = np.nan, inplace = True)
            
            # Return the figure
            #return fig
            
            self.qc_conc_profiles_fig = fig
            print("Figure saved as self.qc_conc_profiles_fig")
        else: 
            print("Interactive plotting is not switched on. Switch on to see plots generated with Plotly. Otherwise, manually create plots. ")
        
    
    #######################################################################################################################
    def qc_conc_timeseries(self):
        """
        
        Plot the TA concentrations calculated within this class for all samples
        Plotted in an interactive plot using plotly so it's easy for the user to identify samples
        
        """
        
        if column_names.interactive == "on":
        
            sdates= self.df[column_names.sampling_date][self.df[column_names.station] != 8888]
            single_measurements= self.df[column_names.alkalinity_umolkg][self.df[column_names.station] != 8888]
            
            single_measurements_allcrm= self.df[column_names.dic_sample_umol_per_kg_allcells][self.df[column_names.station] != 8888]
            
            single_text = np.array(self.df[column_names.sample][self.df[column_names.station] != 8888])
            
            
            # Set lay out properties
            layout = go.Layout(hovermode="closest", title = "Check TA Concentrations for Time Series", )
    
            # Create figure
            fig = go.Figure(layout=layout)
            
            ###
            fig.add_trace(go.Scatter(
                x = sdates, 
                y = single_measurements, 
                mode = "markers", 
                name = "single measurements - crm per day", 
                text = single_text
            ))
            
            ###
            fig.add_trace(go.Scatter(
                x = sdates, 
                y = single_measurements_allcrm, 
                mode = "markers", 
                name = "single measurements - crm total", 
                text = single_text
            ))
            
    
            # Set axes titles
            fig.update_xaxes(title_text = "Time")
            fig.update_yaxes(title_text = "TA [umol kg-1]")
    
            fig.show()
            
            self.qc_conc_timeseries_fig = fig
            print("Figure saved as self.qc_conc_timeseries_fig")
        
        else: 
            print("Interactive plotting is not switched on. Switch on to see plots generated with Plotly. Otherwise, manually create plots. ")
        
    

print("Imported CalcTA class.")        
        
        
        
        